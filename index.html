<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор звука с коррекцией фона</title>
    <style>
        :root {
            --signal-color: #FF0000;       /* Ярко-красный */
            --background-color: #00AA00;    /* Ярко-зелёный */
            --integral-color: #0000FF;     /* Ярко-синий */
            --grid-color: #E0E0E0;         /* Светло-серая сетка */
            --axis-color: #888;            /* Серые оси */
            --secondary-color: #f0f2ff;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --light-text: #666;
            --border-color: #ddd;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: var(--text-color);
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        canvas {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
            margin: 20px auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        #status {
            color: var(--text-color);
            font-weight: 500;
            margin: 15px 0;
            min-height: 24px;
        }
        
        #status.recording {
            color: var(--accent-color);
            animation: blink 1.5s infinite;
        }
        
        #timer {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-color);
            margin: 10px 0;
        }
        
        @keyframes blink {
            50% { opacity: 0.7; }
        }
        
        #graph-title {
            font-weight: 600;
            color: var(--text-color);
            font-size: 20px;
            margin: 25px 0 10px;
            display: none;
        }
        
        button {
            background-color: #4a6bff;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(74, 107, 255, 0.3);
        }
        
        button:hover {
            background-color: #3a5bef;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(74, 107, 255, 0.4);
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .info-box {
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: left;
            border-left: 4px solid #4a6bff;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Анализ интенсивности звука с коррекцией фона</h1>
        
        <div class="info-box">
            <strong>Как использовать:</strong> Нажмите кнопку "Начать запись", разрешите доступ к микрофону. 
            После 15 секунд записи вы увидите график, где:
            <ul>
                <li><span style="color: var(--signal-color); font-weight: bold;">Красная линия</span> - очищенный сигнал</li>
                <li><span style="color: var(--background-color); font-weight: bold;">Зелёная линия</span> - фоновый шум</li>
                <li><span style="color: var(--integral-color); font-weight: bold;">Синяя линия</span> - интегральная кривая</li>
            </ul>
        </div>
        
        <button id="startBtn">Начать запись (15 сек)</button>
        <div id="timer"></div>
        <p id="status">Готов к записи</p>
        
        <p id="graph-title">График интенсивности звука</p>
        <canvas id="graph" width="800" height="400"></canvas>
    </div>

    <script>
        const DURATION = 15;
        const SAMPLE_RATE = 44100;
        const CHUNK_SIZE = 1024;

        const startBtn = document.getElementById('startBtn');
        const timerElement = document.getElementById('timer');
        const statusElement = document.getElementById('status');
        const graphTitle = document.getElementById('graph-title');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');

        let audioContext;
        let analyser;
        let microphone;
        let recordingStartTime;
        let recordingInterval;
        let audioData = [];
        let backgroundNoise = [];
        let isRecording = false;

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: SAMPLE_RATE
            });
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
        }

        async function startRecording() {
            try {
                if (!audioContext) initAudio();
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                recordingStartTime = audioContext.currentTime;
                isRecording = true;
                audioData = [];
                backgroundNoise = [];
                
                startBtn.disabled = true;
                statusElement.textContent = "Идёт запись...";
                statusElement.classList.add('recording');
                graphTitle.style.display = 'none';
                
                processAudio();
                
                let secondsLeft = DURATION;
                updateTimer(secondsLeft);
                
                recordingInterval = setInterval(() => {
                    secondsLeft--;
                    updateTimer(secondsLeft);
                    
                    if (secondsLeft <= 0) {
                        stopRecording();
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Ошибка при записи:', error);
                statusElement.textContent = "Ошибка: " + error.message;
                resetRecordingState();
            }
        }

        function processAudio() {
            if (!isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            const timestamp = audioContext.currentTime - recordingStartTime;
            const normalizedData = Array.from(dataArray).map(x => (x - 128) / 128);
            
            audioData.push({
                time: timestamp,
                data: normalizedData
            });
            
            if (timestamp < 2) {
                backgroundNoise.push({
                    x: timestamp / DURATION,
                    y: calculateRMS(normalizedData)
                });
            }
            
            requestAnimationFrame(processAudio);
        }

        function calculateRMS(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i] * data[i];
            }
            return Math.sqrt(sum / data.length);
        }

        function stopRecording() {
            clearInterval(recordingInterval);
            isRecording = false;
            
            if (microphone) {
                microphone.disconnect();
            }
            
            statusElement.textContent = "Анализ данных...";
            statusElement.classList.remove('recording');
            
            setTimeout(() => {
                processAndDrawData();
                resetRecordingState();
            }, 500);
        }

        function processAndDrawData() {
            if (audioData.length === 0) return;
            
            const avgBackgroundNoise = backgroundNoise.reduce((sum, point) => sum + point.y, 0) / backgroundNoise.length;
            
            const originalSignal = [];
            const backgroundSignal = [];
            
            for (let i = 0; i < audioData.length; i++) {
                const point = audioData[i];
                const intensity = calculateRMS(point.data);
                
                originalSignal.push(intensity);
                backgroundSignal.push({
                    x: point.time / DURATION,
                    y: avgBackgroundNoise
                });
            }
            
            const integralSignal = calculateIntegralCurve(originalSignal, avgBackgroundNoise);
            
            const maxIntegralValue = Math.max(...integralSignal.map(p => p.y));
            const normalizedIntegral = integralSignal.map(p => ({
                x: p.x,
                y: maxIntegralValue > 0 ? p.y / maxIntegralValue : 0
            }));
            
            graphTitle.style.display = 'block';
            drawGraphWithBackground(originalSignal, backgroundSignal, normalizedIntegral, DURATION / originalSignal.length);
        }

        function calculateIntegralCurve(signal, backgroundLevel) {
            const integralPoints = [];
            let integralValue = 0;
            const timeStep = DURATION / signal.length;
            
            for (let i = 0; i < signal.length; i++) {
                const signalValue = Math.max(0, signal[i] - backgroundLevel * 0.8);
                integralValue += signalValue * timeStep;
                
                integralPoints.push({
                    x: i * timeStep / DURATION,
                    y: integralValue
                });
            }
            
            return integralPoints;
        }

        function updateTimer(seconds) {
            timerElement.textContent = `Осталось: ${seconds} сек`;
        }

        function resetRecordingState() {
            startBtn.disabled = false;
            timerElement.textContent = '';
        }

        function drawGraphWithBackground(originalData, backgroundData, integralData, timeStep) {
            if (!originalData || !backgroundData || !integralData || !timeStep) {
                console.error('Некорректные параметры для drawGraphWithBackground');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Улучшенная сетка (более контрастная)
            ctx.beginPath();
            ctx.strokeStyle = 'var(--grid-color)';
            ctx.lineWidth = 1;
            
            // Горизонтальные линии (каждые 0.1)
            for (let i = 0; i <= 1; i += 0.1) {
                const y = canvas.height - i * canvas.height;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            
            // Вертикальные линии (каждую секунду)
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();

            // Оси (более толстые и контрастные)
            ctx.beginPath();
            ctx.strokeStyle = 'var(--axis-color)';
            ctx.lineWidth = 2;
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();

            // Фон (ярко-зелёный)
            ctx.beginPath();
            ctx.strokeStyle = 'var(--background-color)';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            
            for (let i = 0; i < backgroundData.length; i++) {
                const x = backgroundData[i].x * canvas.width;
                const y = canvas.height - backgroundData[i].y * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Очищенный сигнал (ярко-красный)
            ctx.beginPath();
            ctx.strokeStyle = 'var(--signal-color)';
            ctx.lineWidth = 3;
            
            for (let i = 0; i < backgroundData.length; i++) {
                const originalIndex = Math.round(backgroundData[i].x * originalData.length);
                const originalValue = originalData[Math.min(originalIndex, originalData.length - 1)];
                const backgroundValue = backgroundData[i].y;
                const cleanedValue = Math.max(0, originalValue - backgroundValue * 0.8);
                
                const x = backgroundData[i].x * canvas.width;
                const y = canvas.height - cleanedValue * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Интегральная кривая (ярко-синяя)
            ctx.beginPath();
            ctx.strokeStyle = 'var(--integral-color)';
            ctx.lineWidth = 3;
            ctx.setLineDash([3, 3]);
            
            for (let i = 0; i < integralData.length; i++) {
                const x = integralData[i].x * canvas.width;
                const y = canvas.height - integralData[i].y * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Подписи осей X (каждую секунду)
            ctx.font = '12px "Segoe UI", sans-serif';
            ctx.fillStyle = 'var(--text-color)';
            ctx.textAlign = 'center';
            
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.fillText(i.toString(), x, canvas.height - 8);
            }
            
            // Подписи оси Y
            ctx.textAlign = 'right';
            for (let i = 0; i <= 1; i += 0.2) {
                const y = canvas.height - i * canvas.height;
                ctx.fillText(i.toFixed(1), 30, y + 4);
            }

            // Названия осей
            ctx.fillStyle = 'var(--text-color)';
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Время (секунды)', canvas.width / 2, canvas.height - 15);
            
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Нормированная интенсивность', 0, 0);
            ctx.restore();
        }

        startBtn.addEventListener('click', startRecording);
    </script>
</body>
</html>