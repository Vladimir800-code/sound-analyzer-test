<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sound Intensity Analyzer</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        canvas { border: 1px solid black; margin-top: 20px; }
        #status { color: red; }
    </style>
</head>
<body>
    <h1>Анализ интенсивности звука</h1>
    <p>Нажмите кнопку для записи 30 секунд звука.</p>
    <button id="startBtn">Записать</button>
    <p id="status">Для запуска двойным кликом: откройте chrome://flags, найдите #unsafely-treat-insecure-origin-as-secure, добавьте путь к файлу (например, file:///C:/path/to/index.html), перезапустите Chrome.</p>
    <canvas id="graph" width="800" height="400"></canvas>

    <script>
        const startBtn = document.getElementById('startBtn');
        const status = document.getElementById('status');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const DURATION = 30;
        const SAMPLE_RATE = 44100;
        const CHUNK_SIZE = 1024;
        let audioContext;
        let scriptProcessor;
        let audioData = [];

        startBtn.addEventListener('click', async () => {
            try {
                status.textContent = 'Запрос доступа к микрофону...';
                const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: SAMPLE_RATE } });
                audioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
                const source = audioContext.createMediaStreamSource(stream);
                scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);

                scriptProcessor.onaudioprocess = (event) => {
                    const input = event.inputBuffer.getChannelData(0).slice();
                    audioData.push(...input);
                };

                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                startBtn.disabled = true;
                status.textContent = 'Запись звука...';

                setTimeout(() => {
                    scriptProcessor.disconnect();
                    source.disconnect();
                    stream.getTracks().forEach(track => track.stop());
                    audioContext.close();
                    status.textContent = 'Обработка данных...';
                    processAudio();
                }, DURATION * 1000);
            } catch (err) {
                status.textContent = `Ошибка: ${err.message}. Убедитесь, что микрофон разрешен и Chrome-флаг настроен для file://.`;
                console.error('Error:', err);
                startBtn.disabled = false;
            }
        });

        function processAudio() {
            if (audioData.length === 0) {
                status.textContent = 'Ошибка: данные звука не записаны';
                startBtn.disabled = false;
                return;
            }

            const rms = [];
            for (let i = 0; i < audioData.length; i += CHUNK_SIZE) {
                let sum = 0;
                const chunk = audioData.slice(i, i + CHUNK_SIZE);
                for (let j = 0; j < chunk.length; j++) {
                    sum += chunk[j] ** 2;
                }
                rms.push(Math.sqrt(sum / chunk.length));
            }

            // Интегральная кривая, нормированная по единице
            const integral = [];
            let cumulativeSum = 0;
            for (let i = 0; i < rms.length; i++) {
                cumulativeSum += rms[i];
                integral.push(cumulativeSum);
            }
            const maxIntegral = Math.max(...integral, 0.001);
            const normalizedIntegral = integral.map(val => val / maxIntegral);

            const timeStep = DURATION / rms.length;
            drawGraph(normalizedIntegral, timeStep);
            status.textContent = 'График построен!';
            startBtn.disabled = false;
        }

        function drawGraph(data, timeStep) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Сетка
            ctx.beginPath();
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;

            // Вертикальная сетка (шаг 0.1)
            for (let i = 0; i <= 1; i += 0.1) {
                const y = canvas.height - i * canvas.height;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }

            // Горизонтальная сетка (шаг 1 секунда)
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();

            // Кривая
            ctx.beginPath();
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            data.forEach((value, index) => {
                const x = (canvas.width / data.length) * index;
                const y = canvas.height - value * canvas.height * 0.9;
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Оси
            ctx.beginPath();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();

            // Метки шкалы
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';

            // Горизонтальная ось (время, шаг 1 сек)
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.fillText(i, x - 5, canvas.height - 5);
            }

            // Вертикальная ось (нормированная интенсивность, шаг 0.1)
            for (let i = 0; i <= 1; i += 0.1) {
                const y = canvas.height - i * canvas.height;
                ctx.fillText(i.toFixed(1), 5, y + 5);
            }

            // Подписи осей
            ctx.fillText('Время (с)', canvas.width / 2, canvas.height - 20);
            ctx.save();
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Нормированная интегральная интенсивность', -canvas.height / 2, 15);
            ctx.restore();
        }
    </script>
</body>
</html>