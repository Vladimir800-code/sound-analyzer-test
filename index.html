<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ê–Ω–∞–ª–∏–∑ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∑–≤—É–∫–∞</title>
    <style>
        body { 
            font-family: 'Segoe UI', Roboto, Arial, sans-serif; 
            text-align: center; 
            background: #f9fafb;
            margin: 0; padding: 0;
        }
        header {
            background: linear-gradient(135deg, #dbeafe, #eff6ff);
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        h1 { margin: 0; color: #1e3a8a; }
        .sub { margin: 4px 0 0; color:#374151; font-size: 14px; }
        button {
            padding: 10px 20px;
            margin: 10px;
            font-size: 15px;
            border: none;
            border-radius: 10px;
            background: #2563eb;
            color: white;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:hover { background: #1e40af; }
        button:active { transform: scale(0.97); }
        button:disabled { background: #94a3b8; cursor: not-allowed; }
        #status { font-weight: bold; margin: 10px; }
        #status.recording { animation: blink 1s infinite; color: red; }
        @keyframes blink { 50% { opacity: 0; } }
        #graph-title { font-weight: bold; color: #111827; font-size: 18px; margin: 10px 0 0; display: none; }
        canvas { 
            border: 1px solid #cbd5e1; 
            margin-top: 16px; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .legend { margin: 8px auto; color:#111827; }
        .legend span { display:inline-flex; align-items:center; margin:0 10px; }
        .legend i { width:24px; height:3px; display:inline-block; margin-right:6px; }
        .blue { background:#2563eb; }
        .red { background:red; }
    </style>
</head>
<body>
    <header>
        <h1>–ê–Ω–∞–ª–∏–∑ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∑–≤—É–∫–∞</h1>
        <div class="sub">–ó–∞–ø–∏—Å—å 15 —Å–µ–∫—É–Ω–¥ ‚Ä¢ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞–∫–ª–æ–Ω–∞ 0.15 –µ–¥/—Å–µ–∫ ‚Ä¢ –û—Ü–µ–Ω–∫–∞ –ø–æ –æ–∫–Ω—É 0.2 —Å</div>
        <button id="startBtn">üéô –ó–∞–ø–∏—Å–∞—Ç—å</button>
        <p id="status"></p>
    </header>
    <main>
        <p id="graph-title">–ù–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å</p>
        <div class="legend"><span><i class="blue"></i>–æ–±—ã—á–Ω—ã–µ —É—á–∞—Å—Ç–∫–∏</span><span><i class="red"></i>—Å—Ä–µ–∑–∞–Ω–Ω—ã–µ (–Ω–∞–∫–ª–æ–Ω &gt; 0.15)</span></div>
        <canvas id="graph" width="900" height="420"></canvas>
    </main>

    <script>
        const startBtn = document.getElementById('startBtn');
        const status = document.getElementById('status');
        const graphTitle = document.getElementById('graph-title');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');

        const DURATION = 15;             // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏, —Å
        const SAMPLE_RATE = 44100;
        const CHUNK_SIZE = 1024;
        const SLOPE_LIMIT = 0.15;        // –µ–¥/—Å–µ–∫
        const WINDOW_SEC = 0.2;          // –æ–∫–Ω–æ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–æ–π, —Å

        let audioContext;
        let scriptProcessor;
        let audioData = [];

        startBtn.addEventListener('click', async () => {
            try {
                status.textContent = '–ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...';
                const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: SAMPLE_RATE } });
                audioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
                const source = audioContext.createMediaStreamSource(stream);
                scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);

                audioData = [];
                scriptProcessor.onaudioprocess = (event) => {
                    const input = event.inputBuffer.getChannelData(0);
                    // –ö–æ–ø–∏—Ä—É–µ–º, —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±—É—Ñ–µ—Ä–∞
                    audioData.push(...input);
                };

                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                startBtn.disabled = true;
                status.classList.add('recording');
                status.textContent = 'üé§ –ó–∞–ø–∏—Å—å...';

                setTimeout(() => {
                    scriptProcessor.disconnect();
                    source.disconnect();
                    stream.getTracks().forEach(track => track.stop());
                    audioContext.close();
                    status.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö...';
                    status.classList.remove('recording');
                    processAudio();
                }, DURATION * 1000);
            } catch (err) {
                status.textContent = `–û—à–∏–±–∫–∞: ${err.message}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω —Ä–∞–∑—Ä–µ—à–µ–Ω –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è HTTPS –∏–ª–∏ localhost.`;
                status.classList.remove('recording');
                console.error('Error:', err);
                startBtn.disabled = false;
            }
        });

        function processAudio() {
            if (audioData.length === 0) {
                status.textContent = '–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ –∑–≤—É–∫–∞ –Ω–µ –∑–∞–ø–∏—Å–∞–Ω—ã';
                startBtn.disabled = false;
                return;
            }

            // 1) RMS –ø–æ –∫—É—Å–∫–∞–º
            const rms = [];
            for (let i = 0; i < audioData.length; i += CHUNK_SIZE) {
                let sum = 0;
                const chunk = audioData.slice(i, i + CHUNK_SIZE);
                for (let j = 0; j < chunk.length; j++) sum += chunk[j] * chunk[j];
                rms.push(Math.sqrt(sum / chunk.length));
            }

            // 2) –ò–Ω—Ç–µ–≥—Ä–∞–ª –∏ –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞ (–±–∞–∑–∞) –∫ 1.0, –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
            const integral = [];
            let acc = 0;
            for (let i = 0; i < rms.length; i++) { acc += rms[i]; integral.push(acc); }
            const baseEnd = Math.max(integral[integral.length - 1], 1e-9);
            let norm = integral.map(v => v / baseEnd);

            // 3) –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞–∫–ª–æ–Ω–∞ –ø–æ —Å–∫–æ–ª—å–∑—è—â–µ–º—É –æ–∫–Ω—É + –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞
            const dt = DURATION / rms.length;
            const w = Math.max(1, Math.round(WINDOW_SEC / dt));

            function applyLimiter(arr) {
                const out = new Array(arr.length);
                const mask = new Array(arr.length).fill(false);
                out[0] = arr[0];
                for (let i = 1; i < arr.length; i++) {
                    // –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –ø–æ –æ–∫–Ω—É: —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å –∑–Ω–∞—á–µ–Ω–∏–µ–º w —à–∞–≥–æ–≤ –Ω–∞–∑–∞–¥
                    if (i >= w) {
                        const slope = (arr[i] - out[i - w]) / (w * dt);
                        if (slope > SLOPE_LIMIT) { out[i] = out[i - 1]; mask[i] = true; }
                        else { out[i] = arr[i]; }
                    } else {
                        const slope = (arr[i] - out[i - 1]) / dt;
                        if (slope > SLOPE_LIMIT) { out[i] = out[i - 1]; mask[i] = true; }
                        else { out[i] = arr[i]; }
                    }
                }
                return { out, mask };
            }

            // –ü–µ—Ä–≤–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è ‚Äî —Ñ–∏–∫—Å–∞—Ü–∏—è –∏—Å—Ö–æ–¥–Ω—ã—Ö "—Å–ª–∏—à–∫–æ–º –∫—Ä—É—Ç—ã—Ö" —É—á–∞—Å—Ç–∫–æ–≤
            let { out: constrained, mask } = applyLimiter(norm);

            // –î–≤–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏: –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞ -> –ø—Ä–æ–≤–µ—Ä–∫–∞ -> –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞
            for (let pass = 0; pass < 2; pass++) {
                const endVal = Math.max(constrained[constrained.length - 1], 1e-9);
                constrained = constrained.map(v => v / endVal); // –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ 1.0
                const res = applyLimiter(constrained);
                constrained = res.out;
                // –∫–æ–ø–∏–º –º–∞—Å–∫—É (–ª—é–±–æ–π —Å—Ä–µ–∑ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –∫—Ä–∞—Å–Ω—ã–º)
                for (let i = 0; i < mask.length; i++) if (res.mask[i]) mask[i] = true;
            }
            // —Ñ–∏–Ω–∞–ª—å–Ω–∞—è –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞ –∫ 1.0
            const finalEnd = Math.max(constrained[constrained.length - 1], 1e-9);
            constrained = constrained.map(v => v / finalEnd);

            drawGraph(constrained, dt, mask);
            status.textContent = '‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
            graphTitle.style.display = 'block';
            startBtn.disabled = false;
        }

        function drawGraph(data, dt, flatMask) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // —Å–µ—Ç–∫–∞
            ctx.beginPath();
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            const maxY = 1.0, minY = 0.0;
            for (let yv = minY; yv <= maxY + 1e-9; yv += 0.1) {
                const y = canvas.height - (yv - minY) / (maxY - minY) * canvas.height;
                ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
            }
            for (let t = 0; t <= DURATION; t++) {
                const x = (t / DURATION) * canvas.width;
                ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();

            // –æ—Å–Ω–æ–≤–Ω–∞—è –∫—Ä–∏–≤–∞—è (—Å–∏–Ω—è—è)
            ctx.beginPath();
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            for (let i = 0; i < data.length; i++) {
                const x = (i / (data.length - 1)) * canvas.width;
                const y = canvas.height - data[i] * canvas.height;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // –∫—Ä–∞—Å–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã (—Å—Ä–µ–∑–∞–Ω–Ω—ã–µ —à–∞–≥–∏ i-1 -> i)
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            for (let i = 1; i < data.length; i++) {
                if (!flatMask[i]) continue;
                const x1 = ((i - 1) / (data.length - 1)) * canvas.width;
                const y1 = canvas.height - data[i - 1] * canvas.height;
                const x2 = (i / (data.length - 1)) * canvas.width;
                const y2 = canvas.height - data[i] * canvas.height;
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            }
            ctx.stroke();

            // –æ—Å–∏
            ctx.beginPath();
            ctx.strokeStyle = '#0f172a';
            ctx.lineWidth = 1.2;
            ctx.moveTo(0, canvas.height); ctx.lineTo(canvas.width, canvas.height);
            ctx.moveTo(0, 0); ctx.lineTo(0, canvas.height);
            ctx.stroke();

            // –ø–æ–¥–ø–∏—Å–∏
            ctx.font = '12px Segoe UI';
            ctx.fillStyle = '#111827';
            for (let t = 0; t <= DURATION; t++) {
                const x = (t / DURATION) * canvas.width;
                ctx.fillText(t.toString(), x + 2, canvas.height - 6);
            }
            for (let yv = minY; yv <= maxY + 1e-9; yv += 0.1) {
                const y = canvas.height - (yv - minY) / (maxY - minY) * canvas.height;
                ctx.fillText(yv.toFixed(1), 4, y - 2);
            }
            ctx.fillText('–í—Ä–µ–º—è (—Å)', canvas.width / 2 - 28, canvas.height - 10);
            ctx.save(); ctx.rotate(-Math.PI / 2);
            ctx.fillText('–ù–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å', -canvas.height / 2 - 80, 14);
            ctx.restore();
        }
    </script>
</body>
</html>